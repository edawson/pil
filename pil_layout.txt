// Why no database usage in genomics?
// The generic data model for sequencing/sequence variant data is intrisically unstructured so there is no reasonable schema that can be usefully described.
// Fields may be missing and may have 1 or more entries.
// Field ordering may be either unstructured OR the field ordering could have meaning.
// Genomics datasets are the poster child for using columnstore: hundreds of columns with few required for most queries.
// Pivoting data into columnstore enables real-time operational analytics.

// Special symbolic representations
// 0: Unavailable
// 1: Special sentinel node symbol
// All primitive types must accomodate this fact such that all ranges are shortened by 2

/*------   EOF markers   ------*/
// 64-bit XXHASH of "TACHYON-BLOCK-EOF"
const uint64_t PIL_BLOCK_EOF = 7964708207515128046;
// 32b SHA-256 digest
// echo -n "PIL-EOF" | openssl dgst -sha256
const std::string PIL_FILE_EOF = "f6b3d88a5f749ae32da5aa35474e10028ab63b5673105602aa13823f5ad2a73f";
const uint32_t PIL_FILE_EOF_LENGTH = 32;
const std::string PIL_SEGMENT_EOF = "f1189325ec83912f1dfc85189b857d21";
const uint32_t PIL_SEGMENT_EOF_LENGTH = 16;

/*------   Regular expression patterns  ------*/
const std::regex PIL_REGEX_CANONICAL_BASES = std::regex("^[ATGC]+$");
const std::regex PIL_REGEX_CONTIG_ONLY     = std::regex("^[A-Za-z0-9\\-_]+$");
const std::regex PIL_REGEX_CONTIG_POSITION = std::regex("^[A-Za-z0-9\\-_]+\\:[0-9]+([\\.]{1}[0-9]+){0,1}([eE]{1}[0-9]{1})?$");
const std::regex PIL_REGEX_CONTIG_RANGE    = std::regex("^[A-Za-z0-9\\-_]+\\:[0-9]+([\\.]{1}[0-9]+){0,1}([eE]{1}[0-9]{1})?\\-[0-9]+([\\.]{1}[0-9]+){0,1}([eE]{1}[0-9]{1})?$");
const std::regex PIL_REGEX_PACKED_ALLELES  = std::regex("^([ATGCN\\.]{1}){1}|(<NON_REF>){1}$");

/*------ Core enums --------*/
typedef enum {
	PIL_TYPE_UNKNOWN, 
    PIL_TYPE_INT8, 
    PIL_TYPE_UINT8, 
    PIL_TYPE_INT16, 
    PIL_TYPE_UINT16, 
    PIL_TYPE_INT32, 
    PIL_TYPE_UINT32, 
    PIL_TYPE_INT64,
    PIL_TYPE_UINT64,
	PIL_TYPE_FLOAT, 
    PIL_TYPE_DOUBLE, 
    PIL_TYPE_BOOLEAN,
    PIL_TYPE_BYTE_ARRAY, // these must be followed by a second PIL_PRIMITIVE_TYPE in their implementation
	PIL_TYPE_FIXED_LEN_BYTE_ARRAY
} PIL_PRIMITIVE_TYPE;

// BOOLEAN: Bit Packed, LSB first
// INT32: 4 bytes little endian
// INT64: 8 bytes little endian
// FLOAT: 4 bytes IEEE little endian
// DOUBLE: 8 bytes IEEE little endian
// BYTE_ARRAY: length in 4 bytes little endian followed by the bytes contained in the array
// FIXED_LEN_BYTE_ARRAY: the bytes contained in the array

// PLAIN_DICTIONARY
// RLE_DICTIONARY
// EWAH
// DELTA
// DELTA_LENGTH_BYTE_ARRAY
// DELTA_BYTE_ARRAY

typedef enum { PIL_COMPRESS_NONE, PIL_COMPRESS_ZSTD, PIL_COMPRESS_ZPAQ } PIL_COMPRESSION_ENGINE;

typedef enum {
	PIL_ENCRYPTION_NONE, PIL_ENCRYPTION_AES_128, PIL_ENCRYPTION_AES_256_GCM,
	PIL_ENCRYPTION_RSA_4096
} PIL_ENCRYPTION_ENGINE;

/*------ Support statistics --------*/
// Used in Segmental Duplication to more effectively perform predicate
// evaluation on long ranges of data. For example, check if a value in contained
// in a particular Segment. All overlapping Segments will then be used for further
// downstream filtering.
template <class T>
struct public SegmentStatistics {
    bool operator<(const T& ref) const;
    bool operator<=(const T& ref) const;
    bool operator>(const T& ref) const;
    bool operator>=(const T& ref) const;
    bool operator==(const T& ref) const; // equal should be synonymous to contained
    bool operator!=(const T& ref) const; // not equal should be synonymous to not contained
    bool contained(const T& ref) const;
    bool contained(const T& from, const T& to) const;
    bool not_contained(const T& ref) const;
    bool not_contained(const T& from, const T& to) const;

    friend Buffer& operator<<(const SegmentStatistics& sstats);
    friend Buffer& operator>>(SegmentStatistics& sstats);

    T min, max;
};

/*------ Core buffer --------*/
struct Buffer {
    bool owner;
    int64_t n, m; // number of bytes
    uint8_t* data;
};

// ColumnStore can store ANY primitive type: e.g. CHROM, POS
// Initiate the ColumnStore with the largest word size of a primitive family type.
// For example, if you are working with uint8_t values then initiate the ptype
// to uint32_t. Similarly, for precision ptypes, start out with a double. Shrink
// the primitive type in the Segment of a ColumnStore.
//
// Default length of a ColumnStore should be 4096 elements.
//
// A ColumnStore is **MUTABLE** and should be used during importing/constructing
// procedures only. Retrieving data should take place through Array structs and
// downcast to one of its concrete types.
struct ColumnStore {
public:
    int64_t GetLength() const { return buffer.data->n; }
    int64_t GetOffset() const { return buffer.data->offset; }
    
    int GetType() const { return ptype; }

    int Finalize();
    int Finalize(const std::vector<uint32_t>& transforms);

    // Pointer to data.
    std::shared_ptr<ResizableBuffer> data() const { return buffer; }
    std::shared_ptr<ResizableBuffer> bitmap() const { return bitmap; }
    std::shared_ptr<ResizableBuffer> stats() const { return segment_statistics_buffer; }

    // PrettyPrint representation of array suitable for debugging.
    std::string ToString() const;

protected:
    bool sorted; // is this ColumnStore sorted (relative itself)
    uint32_t n, m; // number of elements -> check validity such that n*sizeof(primitive_type)==buffer.size()
    uint32_t ptype; // primtive type encoding, possible bit use for signedness
    uint32_t checksum; // checksum for buffer
    std::vector<uint32_t> transformations; // order of transformations: 
                                           // most usually simply PIL_COMPRESS_ZSTD or more advanced use-cases like 
                                           // PIL_TRANSFORM_SORT, PIL_ENCODE_DICTIONARY, or PIL_COMPRESS_ZSTD
    
    // Any memory is owned by the respective Buffer instance (or its parents).
    MemoryPool* pool_;
    std::shared_ptr<ResizableBuffer> buffer; // Actual data BLOB
    std::shared_ptr<ResizableBuffer> transformation_args; // BLOB storing the parameters for the transformation operations.
    std::shared_ptr<ResizableBuffer> segment_statistics_buffer; // when searching for overlap this MUST be cast to the appropriate primitive type
};

// Concrete type of ColumnStore used during construction from 
// row-centric record structure. 
template <class T>
struct ColumnStoreBuilder : public ColumnStore {
public:
    ColumnStoreBuilder(MemoryPool* pool) : ColumnStore(pool){}

    int Append(const T& value);

    const T* data() const { return reinterpret_cast<const T*>(buffer->mutable_data()); }
    T front() const { return data()[0]; }
    T back() const { return data()[n - 1]; }

public:

};

// Checking ptype requires the following rules
// int8 < int16 < int32 < int64
// float < double
// where it is illegal to upcast


// ColumnSet groups any number of ColumnStores into a joint set of
// columns. This is useful when there are variable length vectors
// of values associated with a single field. This can potentially occur in all
// valid fields such as ALT and in INFO and FORMAT fields.
//
// When ANY of the ColumnStore objects reach the upper limit (batch size) they
// will ALL be processed en-mass and the encapsulaing Segment will be
// processed and flushed.
struct ColumnSet {
    int32_t global_id;
    uint32_t n, m; // batch size of vectors are set to 4096 by default.
    uint32_t checksum; // checksum of the checksum vector -> md5(&checksums, n); this check is to guarnatee there is no accidental reordering of the set
    std::shared_ptr<ColumnStore> dict; // Dictionary encoding of "stride" size.
    std::vector< std::shared_ptr<ColumnStore> > columns;
};

template <class T>
struct ColumnSetBuilder : public ColumnSet {
public:
    ColumnSetBuilder(MemoryPool* pool) : ColumnSet(pool){}

    int Append(const T& value);
    int Append(const std::vector<T>& values);
    int Append(T* value, int n);

    std::vector<int64_t> ColumnLengths() const;

private:
    int UpdateDictionary(int value);

public:

};

// Segment represent a contiguous slice of a columnstore.
// Writing out a Segment should follow the following procedure:
struct Segment {
    uint64_t init_marker; // initation marker for data
    uint32_t n_bytes;
    int32_t global_id; // have to guarantee parity between this parameter and that in columnset->columns
    ColumnSet columnset;
    uint64_t eof_marker;
};

/*------ Indices --------*/
// Supportive structure used in ColumnIndex. Stores the Segmental offsets used
// to support constant lookup queries.
struct SegmentIndex {
    uint32_t global_id; // redundant but useful for checks.
    std::vector<uint64_t> offsets; // virtual file offsets to the Nth Segment.
};

// The ColumnIndex contains vectors of SegmentIndex entries for each ColumnSet
// described in the Dictionary header. This allows us to jump to any Segment offset
// in a ColumnSet in constant time.
struct ColumnIndex {
    std::vector< SegmentIndex > columns;
};

// A SchemaPattern is the collection of ColumnSet identifiers a Record maps to.
// The `ids` vector of identifiers are indirectly encoded as an integer (indirect
// encoding).
struct SchemaPattern {
    uint64_t Hash() const; // return a 64-bit hash of the current pattern
    std::vector<uint32_t> ids;
};

// DictionaryFieldType holds the target field name associated with
// a ColumnSet and the appropriate GLOBAL PIL primitive type.
// This means that all returned values should be compatibile with
// this assigned primitive type.
struct DictionaryFieldType {
    std::string file_name;
    PIL_PRIMITIVE_TYPE ptype;
};

// This inverted index allows us to map each record to the ColumnSet values it
// has in a 1:1 fashion. This index allows us to maintain the individual schema
//
// Every ColumnSet (by default 4096 elements) are emitted as a Segment.
// A collection of Segments are called a Batch. If a particular ColumnSet
// does not appear in the Batch that column identifier will not be used.
//
// We can perform efficient predicate evaluation using vectorized
// instructions (SIMD) on multiple consequtive elements of the dictionary
// encoded patterns.
struct RecordIndexBatch {
    uint32_t n_bitmap, m_bitmap; // n_bitmap MUST correspond to global_ids.size()!
    RoaringBitMap* bitmaps; // column-major bitmap mapping the set-membership of a Record to a ColumnSet.
    std::vector< SchemaPattern > patterns; // number of UNIQUE patterns (multi-sets). Note that different permutations of the same values are considered different patterns.
    HashMap<uint64_t, uint32_t> pattern_map; // Reverse lookup of dictionary-encoded ColumnSet patterns in the Batch.
    HashMap<uint32_t, uint32_t> global_local_map; // Lookup table for global identifiers to the local offset in the Bitmaps.
    std::vector< std::pair<uint32_t, uint32_t> > batch_offsets; // (identifier, batch_offset, batch_el_offset)-tuple for the ColumnSets that exist in this Batch and what the corresponding Segment offset is and the element-wise offset in that Segment.
    ColumnSet patterns; // Array storage of the dictionary-encoded BatchPatterns.
};

// Reverse index from ColumnSet to Records using a collection of Batches.
struct RecordColumnRevIndex {
    std::vector<RecordColumnRevIndexBatch> batches;
};

/*------ Core record structure (in-memory only) --------*/
// Support structure for a record.
struct SegmentOffset {
    uint32_t global_id; // global id of ColumnSet
    uint32_t segment_offset; // segment offset
    uint32_t el_offset; // element offset
};

struct Record {
    std::vector<SegmentOffset> segments; // Segment of a ColumnSet -> ColumnStore
};

// Example use-case:
// table->ColumnIndex("AF")->SegmentIndex(0)->Segment->ColumnSet->ColumnStore(0)->data()
//        ^ Lookup           ^ Find disk offset        ^ ColumnSet                ^ Return immutable data
//                                            ^ Support           ^ First ColumnStore
// Example use:
// auto field1 = std::static_pointer_cast<pil::Int64Array>(table->ColumnIndex("AF")->SegmentIndex(0)->Segment->ColumnSet->ColumnStore(0));


// Supportive structure for importing abstract schemas that can be
// different for every record.
//
// Usage:
// RecordBuilder rb;
// rb.Add("AF");
struct RecordBuilderFields {
    std::string field_name;
    PIL_PRIMITIVE_TYPE primitive_type;
    PIL_PRIMITIVE_TYPE array_primitive_type;
    uint32_t stride;
    size_t n, m;
    uint8_t* data;
};

// Abstraction helper for importing record-centric tuples.
struct RecordBuilder {
public:
    template <class T>
    int Add(const std::string& id, PIL_PRIMITIVE_TYPE, T value);
    
    template <class T>
    int Add(const std::string& id, PIL_PRIMITIVE_TYPE, T* value, uint32_t n_values);
    
    template <class T>
    int Add(const std::string& id, PIL_PRIMITIVE_TYPE, const std::vector<T>& values);

    // Partial specialization for std::string
    int Add(const std::string& id, PIL_PRIMITIVE_TYPE, const std::string& string);

public:
    int n_added;
    uint32_t batch_size;
    
    // Vector of slots.
    std::vector< std::unique_ptr<RecordBuilderFields> > slots;
};

// Specialized importer for HTSLib records.
struct HTSLibRecordBuilder : public RecordBuilder {
    int Add(bcf1_t* rec);
};

//
// A SchemaPattern is the collection of ColumnSet identifiers a Record maps to.
// The `ids` vector of identifiers are indirectly encoded as an integer (indirect
// encoding).
struct SchemaPattern {
    uint64_t Hash() const; // return a 64-bit hash of the current pattern
    std::vector<uint32_t> ids;
};

// DictionaryFieldType holds the target field name associated with
// a ColumnSet and the appropriate GLOBAL PIL primitive type.
// This means that all returned values should be compatibile with
// this assigned primitive type.
struct DictionaryFieldType {
    std::string file_name;
    PIL_PRIMITIVE_TYPE ptype;
};

struct FieldDictionary {
    // Global dictionary of ColumnSet identifiers
    // Field name string -> global identifier (dictionary encoding)
    std::vector<DictionaryFieldType> field_types; // Field typing.
    std::unordered_map<std::string, uint32_t> field_dict; // Field dictonary
};

struct PatternDictionary {
    // Dictionary-encoding of dictionary-encoded of field identifiers as a _Pattern_
    std::vector< SchemaPattern > patterns; // number of UNIQUE patterns (multi-sets). Note that different permutations of the same values are considered different patterns.
    std::unordered_map<uint64_t, uint32_t> pattern_map; // Reverse lookup of Hash of pattern -> pattern ID.
};

struct Table {
public:
    // Accessors
    const SegmentIndex& column(int p);

    // Entry point for adding into the Table
    // Append unknown struct and records its schema.
    // 
    // Internal process:
    // 1) Provide RecordBuilder instance.
    // 2) Foreach slot in Record.
    //   a) Map field_name -> dictionary-encoded identifier.
    //   b) If field_name is not found then insert and return the newly generated identifier.
    //   c) Add value(s) to the current ColumnSet with that identifier.
    //      i) Check that data is compatible: ERROR if not compatible or WARNING if truncating
    // 3) Update RecordIndex
    int Append(RecordBuilder& builder);
    
protected:
    int FindFieldIdentifier(const std::string& field_name) const;
    int AppendRecord();

protected:
    FieldDictionary field_dict;
    PatternDictionary pattern_dict;
   
    // Indices.
    ColumnIndex colindex; // ColumnIndex is updated every time a ColumnSet (Segment) is written to disk.
    RecordColumnRevIndex revindex;
    
private:
    // Construction helpers
    std::unordered_map<uint32_t, uint32_t> _seg_map; // Reverse lookup of current loaded Segment stacks and a provided FieldDict identifier.
    std::vector< std::unique_ptr<Segment> > _seg_stack; // temporary Segments used during construction.
};